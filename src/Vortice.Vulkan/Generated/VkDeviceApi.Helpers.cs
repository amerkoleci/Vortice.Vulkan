// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace Vortice.Vulkan;

unsafe partial class VkDeviceApi
{
	public VkResult vkQueueSubmit(VkQueue queue, VkSubmitInfo submit, VkFence fence)
	{
		return ((delegate* unmanaged<VkQueue, uint, VkSubmitInfo*, VkFence, VkResult>)vkQueueSubmit_ptr.Value)(queue, 1, &submit, fence);
	}

	public VkResult vkQueueSubmit(VkQueue queue, ReadOnlySpan<VkSubmitInfo> submits, VkFence fence)
	{
		fixed (VkSubmitInfo* submitsPtr = submits)
		{
			return ((delegate* unmanaged<VkQueue, uint, VkSubmitInfo*, VkFence, VkResult>)vkQueueSubmit_ptr.Value)(queue, (uint)submits.Length, submitsPtr, fence);
		}
	}

	public VkResult vkFlushMappedMemoryRanges(VkDevice device, VkMappedMemoryRange memoryRange)
	{
		return ((delegate* unmanaged<VkDevice, uint, VkMappedMemoryRange*, VkResult>)vkFlushMappedMemoryRanges_ptr.Value)(device, 1, &memoryRange);
	}

	public VkResult vkFlushMappedMemoryRanges(VkDevice device, ReadOnlySpan<VkMappedMemoryRange> memoryRanges)
	{
		fixed (VkMappedMemoryRange* memoryRangesPtr = memoryRanges)
		{
			return ((delegate* unmanaged<VkDevice, uint, VkMappedMemoryRange*, VkResult>)vkFlushMappedMemoryRanges_ptr.Value)(device, (uint)memoryRanges.Length, memoryRangesPtr);
		}
	}

	public VkResult vkInvalidateMappedMemoryRanges(VkDevice device, VkMappedMemoryRange memoryRange)
	{
		return ((delegate* unmanaged<VkDevice, uint, VkMappedMemoryRange*, VkResult>)vkInvalidateMappedMemoryRanges_ptr.Value)(device, 1, &memoryRange);
	}

	public VkResult vkInvalidateMappedMemoryRanges(VkDevice device, ReadOnlySpan<VkMappedMemoryRange> memoryRanges)
	{
		fixed (VkMappedMemoryRange* memoryRangesPtr = memoryRanges)
		{
			return ((delegate* unmanaged<VkDevice, uint, VkMappedMemoryRange*, VkResult>)vkInvalidateMappedMemoryRanges_ptr.Value)(device, (uint)memoryRanges.Length, memoryRangesPtr);
		}
	}

	public void vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, out uint sparseMemoryRequirementCount)
	{
		sparseMemoryRequirementCount = default;
		fixed (uint* sparseMemoryRequirementCountPtr = &sparseMemoryRequirementCount)
		{
			((delegate* unmanaged<VkDevice, VkImage, uint*, VkSparseImageMemoryRequirements*, void>)vkGetImageSparseMemoryRequirements_ptr.Value)(device, image, sparseMemoryRequirementCountPtr, default);
		}
	}

	public void vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, Span<VkSparseImageMemoryRequirements> sparseMemoryRequirements)
	{
		uint sparseMemoryRequirementCount = checked((uint)sparseMemoryRequirements.Length);
		fixed (VkSparseImageMemoryRequirements* sparseMemoryRequirementsPtr = sparseMemoryRequirements)
		{
			((delegate* unmanaged<VkDevice, VkImage, uint*, VkSparseImageMemoryRequirements*, void>)vkGetImageSparseMemoryRequirements_ptr.Value)(device, image, &sparseMemoryRequirementCount, sparseMemoryRequirementsPtr);
		}
	}

	public VkResult vkQueueBindSparse(VkQueue queue, VkBindSparseInfo bindInfo, VkFence fence)
	{
		return ((delegate* unmanaged<VkQueue, uint, VkBindSparseInfo*, VkFence, VkResult>)vkQueueBindSparse_ptr.Value)(queue, 1, &bindInfo, fence);
	}

	public VkResult vkQueueBindSparse(VkQueue queue, ReadOnlySpan<VkBindSparseInfo> bindInfo, VkFence fence)
	{
		fixed (VkBindSparseInfo* bindInfoPtr = bindInfo)
		{
			return ((delegate* unmanaged<VkQueue, uint, VkBindSparseInfo*, VkFence, VkResult>)vkQueueBindSparse_ptr.Value)(queue, (uint)bindInfo.Length, bindInfoPtr, fence);
		}
	}

	public VkResult vkResetFences(VkDevice device, VkFence fence)
	{
		return ((delegate* unmanaged<VkDevice, uint, VkFence*, VkResult>)vkResetFences_ptr.Value)(device, 1, &fence);
	}

	public VkResult vkResetFences(VkDevice device, ReadOnlySpan<VkFence> fences)
	{
		fixed (VkFence* fencesPtr = fences)
		{
			return ((delegate* unmanaged<VkDevice, uint, VkFence*, VkResult>)vkResetFences_ptr.Value)(device, (uint)fences.Length, fencesPtr);
		}
	}

	public VkResult vkWaitForFences(VkDevice device, VkFence fence, VkBool32 waitAll, ulong timeout)
	{
		return ((delegate* unmanaged<VkDevice, uint, VkFence*, VkBool32, ulong, VkResult>)vkWaitForFences_ptr.Value)(device, 1, &fence, waitAll, timeout);
	}

	public VkResult vkWaitForFences(VkDevice device, ReadOnlySpan<VkFence> fences, VkBool32 waitAll, ulong timeout)
	{
		fixed (VkFence* fencesPtr = fences)
		{
			return ((delegate* unmanaged<VkDevice, uint, VkFence*, VkBool32, ulong, VkResult>)vkWaitForFences_ptr.Value)(device, (uint)fences.Length, fencesPtr, waitAll, timeout);
		}
	}

	public VkResult vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, VkPipelineCache srcCache)
	{
		return ((delegate* unmanaged<VkDevice, VkPipelineCache, uint, VkPipelineCache*, VkResult>)vkMergePipelineCaches_ptr.Value)(device, dstCache, 1, &srcCache);
	}

	public VkResult vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, ReadOnlySpan<VkPipelineCache> srcCaches)
	{
		fixed (VkPipelineCache* srcCachesPtr = srcCaches)
		{
			return ((delegate* unmanaged<VkDevice, VkPipelineCache, uint, VkPipelineCache*, VkResult>)vkMergePipelineCaches_ptr.Value)(device, dstCache, (uint)srcCaches.Length, srcCachesPtr);
		}
	}

	public VkResult vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorSet descriptorSet)
	{
		return ((delegate* unmanaged<VkDevice, VkDescriptorPool, uint, VkDescriptorSet*, VkResult>)vkFreeDescriptorSets_ptr.Value)(device, descriptorPool, 1, &descriptorSet);
	}

	public VkResult vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, ReadOnlySpan<VkDescriptorSet> descriptorSets)
	{
		fixed (VkDescriptorSet* descriptorSetsPtr = descriptorSets)
		{
			return ((delegate* unmanaged<VkDevice, VkDescriptorPool, uint, VkDescriptorSet*, VkResult>)vkFreeDescriptorSets_ptr.Value)(device, descriptorPool, (uint)descriptorSets.Length, descriptorSetsPtr);
		}
	}

	public void vkCmdSetViewport(VkCommandBuffer commandBuffer, uint firstViewport, VkViewport viewport)
	{
		((delegate* unmanaged<VkCommandBuffer, uint, uint, VkViewport*, void>)vkCmdSetViewport_ptr.Value)(commandBuffer, firstViewport, 1, &viewport);
	}

	public void vkCmdSetViewport(VkCommandBuffer commandBuffer, uint firstViewport, ReadOnlySpan<VkViewport> viewports)
	{
		fixed (VkViewport* viewportsPtr = viewports)
		{
			((delegate* unmanaged<VkCommandBuffer, uint, uint, VkViewport*, void>)vkCmdSetViewport_ptr.Value)(commandBuffer, firstViewport, (uint)viewports.Length, viewportsPtr);
		}
	}

	public void vkCmdSetScissor(VkCommandBuffer commandBuffer, uint firstScissor, VkRect2D scissor)
	{
		((delegate* unmanaged<VkCommandBuffer, uint, uint, VkRect2D*, void>)vkCmdSetScissor_ptr.Value)(commandBuffer, firstScissor, 1, &scissor);
	}

	public void vkCmdSetScissor(VkCommandBuffer commandBuffer, uint firstScissor, ReadOnlySpan<VkRect2D> scissors)
	{
		fixed (VkRect2D* scissorsPtr = scissors)
		{
			((delegate* unmanaged<VkCommandBuffer, uint, uint, VkRect2D*, void>)vkCmdSetScissor_ptr.Value)(commandBuffer, firstScissor, (uint)scissors.Length, scissorsPtr);
		}
	}

	public VkResult vkBindBufferMemory2(VkDevice device, VkBindBufferMemoryInfo bindInfo)
	{
		return ((delegate* unmanaged<VkDevice, uint, VkBindBufferMemoryInfo*, VkResult>)vkBindBufferMemory2_ptr.Value)(device, 1, &bindInfo);
	}

	public VkResult vkBindBufferMemory2(VkDevice device, ReadOnlySpan<VkBindBufferMemoryInfo> bindInfos)
	{
		fixed (VkBindBufferMemoryInfo* bindInfosPtr = bindInfos)
		{
			return ((delegate* unmanaged<VkDevice, uint, VkBindBufferMemoryInfo*, VkResult>)vkBindBufferMemory2_ptr.Value)(device, (uint)bindInfos.Length, bindInfosPtr);
		}
	}

	public VkResult vkBindImageMemory2(VkDevice device, VkBindImageMemoryInfo bindInfo)
	{
		return ((delegate* unmanaged<VkDevice, uint, VkBindImageMemoryInfo*, VkResult>)vkBindImageMemory2_ptr.Value)(device, 1, &bindInfo);
	}

	public VkResult vkBindImageMemory2(VkDevice device, ReadOnlySpan<VkBindImageMemoryInfo> bindInfos)
	{
		fixed (VkBindImageMemoryInfo* bindInfosPtr = bindInfos)
		{
			return ((delegate* unmanaged<VkDevice, uint, VkBindImageMemoryInfo*, VkResult>)vkBindImageMemory2_ptr.Value)(device, (uint)bindInfos.Length, bindInfosPtr);
		}
	}

	public void vkGetImageSparseMemoryRequirements2(VkDevice device, VkImageSparseMemoryRequirementsInfo2* info, out uint sparseMemoryRequirementCount)
	{
		sparseMemoryRequirementCount = default;
		fixed (uint* sparseMemoryRequirementCountPtr = &sparseMemoryRequirementCount)
		{
			((delegate* unmanaged<VkDevice, VkImageSparseMemoryRequirementsInfo2*, uint*, VkSparseImageMemoryRequirements2*, void>)vkGetImageSparseMemoryRequirements2_ptr.Value)(device, info, sparseMemoryRequirementCountPtr, default);
		}
	}

	public void vkGetImageSparseMemoryRequirements2(VkDevice device, VkImageSparseMemoryRequirementsInfo2* info, Span<VkSparseImageMemoryRequirements2> sparseMemoryRequirements)
	{
		uint sparseMemoryRequirementCount = checked((uint)sparseMemoryRequirements.Length);
		fixed (VkSparseImageMemoryRequirements2* sparseMemoryRequirementsPtr = sparseMemoryRequirements)
		{
			((delegate* unmanaged<VkDevice, VkImageSparseMemoryRequirementsInfo2*, uint*, VkSparseImageMemoryRequirements2*, void>)vkGetImageSparseMemoryRequirements2_ptr.Value)(device, info, &sparseMemoryRequirementCount, sparseMemoryRequirementsPtr);
		}
	}

	public VkResult vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, out uint swapchainImageCount)
	{
		swapchainImageCount = default;
		fixed (uint* swapchainImageCountPtr = &swapchainImageCount)
		{
			return ((delegate* unmanaged<VkDevice, VkSwapchainKHR, uint*, VkImage*, VkResult>)vkGetSwapchainImagesKHR_ptr.Value)(device, swapchain, swapchainImageCountPtr, default);
		}
	}

	public VkResult vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, Span<VkImage> swapchainImages)
	{
		uint swapchainImageCount = checked((uint)swapchainImages.Length);
		fixed (VkImage* swapchainImagesPtr = swapchainImages)
		{
			return ((delegate* unmanaged<VkDevice, VkSwapchainKHR, uint*, VkImage*, VkResult>)vkGetSwapchainImagesKHR_ptr.Value)(device, swapchain, &swapchainImageCount, swapchainImagesPtr);
		}
	}

}
